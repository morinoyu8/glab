# Technical "whitepaper" for afl-fuzz

- AFL の内部構造についての説明
- AFL の使用方法は README
- AFL の動機と設計目標については historical_notes.txt を参照

## 1. カバレッジ測定

- プログラムへの計装はエッジカバレッジと分岐を通った回数をカウント
- プログラムに挿入されるコード

```c
cur_location = <COMPILE_TIME_RANDOM>;
shared_mem[cur_location ^ prev_location]++; 
prev_location = cur_location >> 1;
```

- `cur_location` の値はランダムに生成される
- `shared_mem[]` 配列は計装されたバイナリに渡される 64KB の共有メモリ領域
  - `(branch_src, branch_dst)` のタプルのヒットとみなすことができる

<br/>

- マップのサイズは通常 2k から 10k の分岐数を持つほとんどのターゲットに対して, 衝突がまれにしか発生しないように選ばれる

    | ブランチ数 | 衝突タプル | ターゲット例
    | ---: | :--- | :--- |
    | 1,000 | 0.75% | giflib, lzo |
    | 2,000 | 1.5% | zlib, tar, xz |
    | 5,000 | 3.5% | libpng, libwebp |
    | 10,000 | 7% | libxml |
    | 20,000 | 14% | sqlite |
    | 50,000 | 30% | - |

- 同時に, このサイズは受信側でマップをマイクロ秒単位で解析できるように, L2 キャッシュ内に収まるようにしている
- この形式のカバレッジは単純なブロックカバレッジよりもより深い洞察を (次が区別できる)
  - A -> B -> C -> D -> E (tuples: AB, BC, CD, DE)
  - A -> B -> D -> C -> E (tuples: AB, BD, DC, CE)
- これによって微妙な脆弱性の発見が促進される
  - セキュリティ脆弱性は新しい基本ブロックに到達するよりも予期しない・誤った状態遷移に関連することが多い
  
<br/>

- シフト操作を行う2つの理由
  - タプルの方向性を保持する (A -> B と B -> A を区別する)
  - 自己ループを区別する (シフトがないと, A -> A と B -> B が同じになってしまう)

<br/>

- Intel CPU で簡単な飽和算術演算が存在しないため, ヒットカウンタがゼロに巻き戻るかも
  - 稀だから気にしない

<br/>

## 2. 新しい動作の検出

- ファザーは過去の実行で見られたタプルのグローバルマップを保持する
  - このデータは個々のトレースと迅速に比較され, 数個のタブル or クワッドワイドの命令 (16, 64ビットの命令?) と単純なループで更新できる
- 変異した入力が新しいタプルを含む実行トレースを生成すると, その入力ファイルが保存される
  - 逆に新しいタプルを生成しないものは破棄される
- これによってパス爆発を防ぐ

<br/>

- 以下の例では新しいタプル (CA, AE) が存在するため, 2番目のトレースは新しいものとみなされる
  - #1: A -> B -> C -> D -> E
  - #2: A -> B -> C -> A -> E
- その後の以下のパターンは実行パスが大きく異なるが, 新しいタプルがないため, 新しいものとみなされない
  - #3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E

<br/>

- 新しいタプルの検出に加えて, タプルヒットカウントも計測する (以下のバケットに分けられる)
  - 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+
- 8ビットカウンタを1ビットごとにそれぞれのバケットにする
- 新しいバケットに触れると興味深いものとしてフラグが立てられ, テストケースが保存される
  - 通常1回しか実行されないエッジを2回通ったときと区別できる
  - 同時に, 47 サイクルから 48 サイクルのような経験的にあまり注目されない変化には鈍感
  - タプルの衝突における免疫もある程度提供

<br/>

- 実行はメモリと実行時間の制限によって厳しく管理
- デフォルトでは, タイムアウトは初期キャリブレーションされた実行速度の5倍に設定され, 20msで切り上げられる
  - ファザーのパフォーマンスが劇的に低下するのを防ぐ
