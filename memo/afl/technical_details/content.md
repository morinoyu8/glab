# Technical "whitepaper" for afl-fuzz

https://github.com/google/AFL/blob/master/docs/technical_details.txt

- AFL の内部構造についての説明
- AFL の使用方法は README
- AFL の動機と設計目標については historical_notes.txt を参照

## 1. カバレッジ測定

- プログラムへの計装はエッジカバレッジと分岐を通った回数をカウント
- プログラムに挿入されるコード

```c
cur_location = <COMPILE_TIME_RANDOM>;
shared_mem[cur_location ^ prev_location]++; 
prev_location = cur_location >> 1;
```

- `cur_location` の値はランダムに生成される
- `shared_mem[]` 配列は計装されたバイナリに渡される 64KB の共有メモリ領域
  - `(branch_src, branch_dst)` のタプルのヒットとみなすことができる

<br/>

- マップのサイズは通常 2k から 10k の分岐数を持つほとんどのターゲットに対して, 衝突がまれにしか発生しないように選ばれる

    | ブランチ数 | 衝突タプル | ターゲット例
    | ---: | :--- | :--- |
    | 1,000 | 0.75% | giflib, lzo |
    | 2,000 | 1.5% | zlib, tar, xz |
    | 5,000 | 3.5% | libpng, libwebp |
    | 10,000 | 7% | libxml |
    | 20,000 | 14% | sqlite |
    | 50,000 | 30% | - |

- 同時に, このサイズは受信側でマップをマイクロ秒単位で解析できるように, L2 キャッシュ内に収まるようにしている
- この形式のカバレッジは単純なブロックカバレッジよりもより深い洞察を (次が区別できる)
  - A -> B -> C -> D -> E (tuples: AB, BC, CD, DE)
  - A -> B -> D -> C -> E (tuples: AB, BD, DC, CE)
- これによって微妙な脆弱性の発見が促進される
  - セキュリティ脆弱性は新しい基本ブロックに到達するよりも予期しない・誤った状態遷移に関連することが多い
  
<br/>

- シフト操作を行う2つの理由
  - タプルの方向性を保持する (A -> B と B -> A を区別する)
  - 自己ループを区別する (シフトがないと, A -> A と B -> B が同じになってしまう)

<br/>

- Intel CPU で簡単な飽和算術演算が存在しないため, ヒットカウンタがゼロに巻き戻るかも
  - 稀だから気にしない

<br/>

## 2. 新しい動作の検出

- ファザーは過去の実行で見られたタプルのグローバルマップを保持する
  - このデータは個々のトレースと迅速に比較され, 数個のタブル or クワッドワイドの命令 (16, 64ビットの命令?) と単純なループで更新できる
- 変異した入力が新しいタプルを含む実行トレースを生成すると, その入力ファイルが保存される
  - 逆に新しいタプルを生成しないものは破棄される
- これによってパス爆発を防ぐ

<br/>

- 以下の例では新しいタプル (CA, AE) が存在するため, 2番目のトレースは新しいものとみなされる
  - #1: A -> B -> C -> D -> E
  - #2: A -> B -> C -> A -> E
- その後の以下のパターンは実行パスが大きく異なるが, 新しいタプルがないため, 新しいものとみなされない
  - #3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E

<br/>

- 新しいタプルの検出に加えて, タプルヒットカウントも計測する (以下のバケットに分けられる)
  - 1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+
- 8ビットカウンタを1ビットごとにそれぞれのバケットにする
- 新しいバケットに触れると興味深いものとしてフラグが立てられ, テストケースが保存される
  - 通常1回しか実行されないエッジを2回通ったときと区別できる
  - 同時に, 47 サイクルから 48 サイクルのような経験的にあまり注目されない変化には鈍感
  - タプルの衝突における免疫もある程度提供

<br/>

- 実行はメモリと実行時間の制限によって厳しく管理
- デフォルトでは, タイムアウトは初期キャリブレーションされた実行速度の5倍に設定され, 20msで切り上げられる
  - ファザーのパフォーマンスが劇的に低下するのを防ぐ

<br/>

## 3. 入力キューの成長

- プログラム内で新しい状態遷移を生じた変異テストケースは入力キューに追加され, 将来のファジングに使用される
- このアプローチでは, 基礎となるデータフォーマットの様々な不連続で, おそらく相互に互換性のない特徴を, 段階的に探索することができる :
  
  <img src="http://lcamtuf.coredump.cx/afl/afl_gzip.png" class="img-100" />

- このプロセスで生成された合成コーパスは, 本質的に何か新しいものをするだろうという入力ファイルのコレクション
  - 後続の他のテストプロセスのシードとすることもできる
- このアプローチによってほとんどのターゲットのキューは 1k から 10k に成長する
  - 10-30% が新しいタプルの発見に関連し, 残りはヒットカウントの変化に関連する
- ここから AFL はすごいよって話が書かれている

<br/>

## 4. コーパスの選択

- 後半で生成されたテストケースは, その祖先が提供するカバレッジの厳密なスーパーセットのエッジカバレッジを持つ可能性が高い
- ファジングの効率を上げるために, AFL は定期的にキューを再評価
  - これまで見られたすべてのタプルをカバーし, ツールにとって特に有利な特性を持つテストケースのより小さなサブセットを選択するアルゴリズム

<br/>

- このアルゴリズムは各キューのエントリに実行レイテンシとファイルサイズに比例したスコアを割り当てる
- 各タプルの最低スコアの候補を選択することで機能する

<br/>

- 次にタプルはシンプルなワークフローで実行
  1. 一時的な working set にまだないタプルを見つける
  2. このタプルの勝利キューエントリを見つける
  3. そのエントリのトレースに存在するすべてのタプルを working set に含める
  4. working set にないタプルがまだあるなら, 1に戻る


<br/>

- 生成された "favored" エントリのコーパスは通常のコーパスの 5~10倍小さくなる
- 好ましくないエントリは破棄されないがキューで遭遇したときに異なる確率でスキップされる
  - キューにまだファジングされていない新しいエントリがあるなら, 99% の好ましくないエントリがスキップ
  - 新しい好ましいエントリがない場合
    - キューから取り出した好ましくないエントリが以前にファジングされているなら, 95% の確率でスキップ
    - まだファジングされていなければ, 75%の確率でスキップ

<br/>

- これは実証実験に基づいて, キューのサイクル速度とテストケースの多様性が合理的に保たれる
- 洗練されたがはるかに遅い選択では `afl-cmin` を使用して実行できる
  - 冗長なエントリーを永久に破棄する