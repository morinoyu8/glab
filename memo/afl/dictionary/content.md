# afl-fuzz: making up grammar with a dictionary in hand

https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html

<br/>

- AFL の変異エンジンはシンタックスブラインド
  - バイナリや人間が読めるデータフォーマットに最適化されている
  - `Set-Cookie: FOO=BAR` から `Content-Length: -1` へランダムに変異させるのは難しい

<br/>

- このような複雑な文法でファジングしたければ, 構文テンプレートを組み込んだ, プロトコル固有の変異エンジンが必要
  - これは非常に難しい

<br/>

- AFL に基本的な構文トークンのリストを与えると, フィードバックによって, 無意味なものと文法に従って新しい状態をトリガーするものを区別できる
  - 使用で定義されている予約キーワードのセットなど
- 前者を捨て, 後者の入力をさらに変異させることで, 複雑で意味のある構文を徐々に構築していくことが可能

<br/>

- 簡単なアイデアだが実装すると非常に良かった
- 例えば, プロジェクトのドキュメント (-x testcases/_extras/sql/) から取り出したキーワードをファザーに与えて, sqlite に対して試した
- この知識を装備した `afl-fuzz` は普通でない文であっても, 有効な文の範囲を素早く吐き出した :

```
select sum(1)LIMIT(select sum(1)LIMIT -1,1);
select  round( -1)````;
select group_concat(DISTINCT+1) |1;
select length(?)in( hex(1)+++1,1);
select abs(+0+ hex(1)-NOT+1) t1;
select DISTINCT "Y","b",(1)"Y","b",(1);
select - (1)AND"a","b";
select ?1in(CURRENT_DATE,1,1);
select - "a"LIMIT- /* */ /* */- /* */ /* */-1;
select strftime(1, sqlite_source_id());
```

<br/>

- キーワードを取得するのは, 基本的な文法を指定するよりは簡単だが, 多少の作業が必要
- 適切な辞書を構築する気のない人の助けになる, シンプルなアルゴリズムを思いついた

<br/>

- PNG ファイルの例で見る
- PNG フォーマットでは, セクションの先頭を示すために, 4バイトの人間が読めるマジック値を使う

```
89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 | .PNG........IHDR
00 00 00 20 00 00 00 20 02 03 00 00 00 0e 14 92 | ................
```

<br/>

- このアルゴリズムは, 決定論的ビット反転によって, 構文トークンとして "IHDR" を識別することができる
- 単純な特性を満たすバイト列を識別することで動作する
- つまり, バイト列を反転させると, 隣接する領域で反転されたものとは異なる実行パスがトリガーされるが, バイト列全体では一貫している?

<br/>

- このシグナルは `header.magic_value == 0xDEADBEEF` や `strcmp(name, "Set-Cookie")` のような影響を受けるバイトのいずれかに触れることで, 基本的なチェックに失敗する
- このような動作が検出されると, データの塊全体が辞書に追加され, あとで他の辞書トークンとランダムに再結合される

<br/>

- これは手作業で作成した適切なキーワードリストの代わりにはならない
- 入力ファイルに存在するか, 簡単に合成できる構文トークンしか知らない
- アトミックな文字列比較を行わない, 最適化されたツリーベースのパーサーに対しては, 大したことができない
  - ファザーはこの障害をクリアすることも多いが, 時間がかかる