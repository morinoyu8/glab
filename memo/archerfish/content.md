# When Threads Meet Interrupts: Effective Static Detection of Interrupt-Based Deadlocks in Linux [SEC'24]

## Abstract

- デッドロックはスレッドがロックを保持したまま, 他のスレッドがすでに保持している他のロックを取得しようとするときに発生するソフトウェアの応答不能状態のことで, 循環的なロック依存関係が発生する
- 割り込みベースのデッドロックは, 割り込みによってカーネル内で発生するデッドロックの一種
  - システム機能, パフォーマンス, セキュリティに重大なリスクをもたらす
- 既存の静的解析ツールは割り込みを特徴づけることなく, リソースベースのデッドロックに焦点を当てる
- Archerfish は Linux カーネルにおける割り込みベースのデッドロックを効果的に特定する静的解析アプローチ
- Archerfish は割り込み認識ロックグラフ (Interrupt-Aware Lock Graph: ILG) を利用して, 通常のロック依存性と割り込みロック依存性の両方を捕える
  - デッドロックの検出問題をグラフサイクルの発見と絞り込みに軽減する
- さらに, ILG の構築とデッドロックサイクルの絞り込みのために4つの解析コンポーネントを組み込む
- 以下の3つの課題に対処
  - 広範囲の割り込みに関連する並行空間
  - 潜在的な割り込みハンドラの特定
  - デッドロックサイクルの実現可能性の検証
- 実験結果は Archerfish が Linux カーネル (19.8 MLoC) を約1時間で正確に解析できる
- 未知のデッドロックを76個発見
- 発見されたデッドロックの潜伏期間が平均9.9年間である

<br/>

## 1. Introduction

- デッドロックは各スレッドがロックを保持しながら, 他のスレッドがすでに保持されている別のロックを取得しようとする, 循環的なロック依存関係によって引き起こされる応答不能状態
- カーネルでは割り込みによって, すでにロックを獲得している割り込まれたスレッドが, 割り込み処理の中で追加の処理を獲得しようとする時, 更なるロック依存性が発生する可能性がある [[参考](https://github.com/torvalds/linux/commit/8d61f926d42045961e6b65191c09e3678d86a9cf)]
- このようなことを割り込みベースのデッドロックと呼ぶ

<br/>

- デッドロックはシステム機能性, パフォーマンス, セキュリティを著しく損なう可能性がある
- 割り込みベースのデッドロックは, 割り込みコンテキスト内で発生するため, さらに深刻な危険をもたらす可能性があり, CPU コア全体が応答しなくなり, システム全体が破壊される可能性も
- 割り込みベースのデッドロックの発見は静的・動的にも既存手法では限界がある

<br/>

- 既存の静的アプローチは主にスレッドのインターリーブによって引き起こされるリソースベースのデッドロック検出に焦点を当てる
- 割り込みベースのデッドロックを見落としている
- 割り込みをスレッドとして直接扱うことで伝統的なスレッドインターリーブモデルを使用している
  - つまり, 同じスレッドで割り込みがあったときのデッドロックを見ていないということ?

<br/>

- 動的なアプローチはカバレッジが低く, 外部デバイスなどの実行環境に依存することが多い
- 動的ファジングは, Linux カーネル内蔵のロック検証ツールである Lockdep の支援によりデッドロックを検出できる
- これらは実行を欠陥のあるパスに導くために高品質のシード入力を可能にする
- さらに, 割り込み preemption は動的並行実行の探索空間を大幅に拡大し, 有効性を低下させる
- 割り込みの動的トリガーはハードウェアデバイスが生成する信号に大きく依存する
  - これは時に適切に実行・利用することが難しい

<br/>

<img src="./images/figure1.png" class="img-100" />

- 図1(a) の例はスレッドA とスレッドB の2つのスレッド間の循環ロック依存関係によって引き起こされる割り込みベースのデッドロックを示す
- スレッドA は184行目で &dev->irqlock を取得し, 195行目で関数 clear_work_bit() を呼び出し, 52行目で &dev->condlock を取得している
  - これによって &dev->irqlock から &dev->condlock へのロック依存関係が確立される
- スレッドB はコールバック関数 enc_post_frame_start() の中で, 300行目で clear_work_bit() 関数を呼び出し, &dev->irqlock を取得
- このとき, 割り込みハンドラ s5p_mfs_irq() は無効化されていないため, 52 から 54行目の間に, 割り込みハンドラが入る可能性がある
- この割り込みハンドラ内で &dev->irqlock を取得すると &dev->condlock から &dev->irqlock への割り込みロック依存関係が形成される
- この割り込みロック依存性は既存の静的メソッドでは取得できない
- 特定の並行スケジューリングでは図1(b) に示すような割り込みベースのデッドロックが発生し, システムが停止する可能性がある

<br/>

#### Our Approach

- 本論文は Linux カーネルにおける割り込みベースのデッドロックを検出するために, 割り込みの preemption を特徴づける初の静的アプローチ Archerfish を紹介する
- Archerfish は割り込み考慮ロックグラフ (Interrupt-Aware Lock Graph: ILG) を使う
  - ILG : スレッドの通常の実行フローと割り込み preemption によってそれぞれ引き起こされる, 通常のロック依存性と割り込みロック依存性の2つのロック依存性をキャプチャする
- ILG を効果的に構築することで割り込みベースのデッドロック検出を, 依存サイクルの発見と検証に減らすことができる
  - 例えば, 図1(a) のデッドロックは図1(c) のサイクルを見つけることで検出できる

<br/>

- しかし, Linux カーネルを効果的に解析してロックの依存関係を特定し, デッドロックサイクルを正確に作ることは3つの課題がある

  1. 割り込みサービスルーチン (ISR) (= 割り込みハンドラ?) の特定は, Linux カーネル内の異なるサブシステムが ISR を登録するために独自の API とコールバックインターフェースを持っていることが多いため, ドメイン固有の知識がないと困難
  2. 割り込みの preemption は静的解析の並行性推論空間を拡大する
     - 割り込みが有効な各プログラムは割り込みの可能性があるため, 各ステートメントすべてで割り込みを考慮する必要があるかも
  3. 割り込みとプログラムパスの両方の実現可能性を考慮して, 実現可能なロック依存関係を特定することが極めて重要
     - 例えば SMT を使って多数のロック依存関係のパスを直接検証することは効率が悪い

<br/>

<img src="./images/figure2.png" class="img-50" />

- この3つの課題に対処するため, 図2に示すような4つのステージを設計

<br/>

- 1つ目は, 1つ目の課題を解決するために, LLM の力を利用して, 割り込みを識別するために手動でモデル化したものを補完する割り込み仕様を生成する
- LLM は Linux カーネルに対する情報を含む膨大な量のオンラインテキストデータでトレーニングされているため

<br/>

- 2つ目は, ロックセットと関連するステートメントでの割り込みの有効/無効の状態を計算するために, サマリベースのデータフロー解析を採用する
- 割り込みの preemption が膨大な空間であるという課題に取り組むために, preemption unit という概念を導入し, クリティカルセクション内のすべてのステートメントをクラスタリングする
- 重要なアイデアは, クリティカルセクションが同じロックセットを共有し, その領域内で発生する割り込みが同じロックセットを保持すること
- ロックセット解析の際に, 領域内の個々のプログラムポイントを個別に計算する必要はない

<br/>

- 3つ目は, 計算されたデータフローの事実を使用して, ILG を構築し, 両方のロック依存関係をグラフエッジとしてキャプチャする
- ILG 内の依存サイクルを特定し, 割り込みベースのデッドロックを表す

<br/>

- 4つ目は, 高価なデッドロックの実現可能性チェックという課題の克服
- 重要なアイデアはすべてのロック依存性がデッドロック検出に関連しているわけではない
- ILG 構築中に各エッジを早期に検証する代わりに, 発見されたサイクルごとにコストのかかる検証を延期し, 割り込みとパスの両方の実現可能性を遅延的にチェックする

<br/>

- Archerfish は LLVM フレームワーク上で実装され, Linux v6.4 で評価した
- Linux カーネル (19.8 MLoC) を約1時間で比較的低い正解率 (49.7%) で解析することができる
- Linux カーネルの新しい, 長期にわたって存在する割り込みベースのデッドロックを発見した