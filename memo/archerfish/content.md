# When Threads Meet Interrupts: Effective Static Detection of Interrupt-Based Deadlocks in Linux [SEC'24]

## Abstract

- デッドロックはスレッドがロックを保持したまま, 他のスレッドがすでに保持している他のロックを取得しようとするときに発生するソフトウェアの応答不能状態のことで, 循環的なロック依存関係が発生する
- 割り込みベースのデッドロックは, 割り込みによってカーネル内で発生するデッドロックの一種
  - システム機能, パフォーマンス, セキュリティに重大なリスクをもたらす
- 既存の静的解析ツールは割り込みを特徴づけることなく, リソースベースのデッドロックに焦点を当てる
- Archerfish は Linux カーネルにおける割り込みベースのデッドロックを効果的に特定する静的解析アプローチ
- Archerfish は割り込み認識ロックグラフ (Interrupt-Aware Lock Graph: ILG) を利用して, 通常のロック依存性と割り込みロック依存性の両方を捕える
  - デッドロックの検出問題をグラフサイクルの発見と絞り込みに軽減する
- さらに, ILG の構築とデッドロックサイクルの絞り込みのために4つの解析コンポーネントを組み込む
- 以下の3つの課題に対処
  - 広範囲の割り込みに関連する並行空間
  - 潜在的な割り込みハンドラの特定
  - デッドロックサイクルの実現可能性の検証
- 実験結果は Archerfish が Linux カーネル (19.8 MLoC) を約1時間で正確に解析できる
- 未知のデッドロックを76個発見
- 発見されたデッドロックの潜伏期間が平均9.9年間である

<br/>

## 1. Introduction

- デッドロックは各スレッドがロックを保持しながら, 他のスレッドがすでに保持されている別のロックを取得しようとする, 循環的なロック依存関係によって引き起こされる応答不能状態
- カーネルでは割り込みによって, すでにロックを獲得している割り込まれたスレッドが, 割り込み処理の中で追加の処理を獲得しようとする時, 更なるロック依存性が発生する可能性がある [[参考](https://github.com/torvalds/linux/commit/8d61f926d42045961e6b65191c09e3678d86a9cf)]
- このようなことを割り込みベースのデッドロックと呼ぶ

<br/>

- デッドロックはシステム機能性, パフォーマンス, セキュリティを著しく損なう可能性がある
- 割り込みベースのデッドロックは, 割り込みコンテキスト内で発生するため, さらに深刻な危険をもたらす可能性があり, CPU コア全体が応答しなくなり, システム全体が破壊される可能性も
- 割り込みベースのデッドロックの発見は静的・動的にも既存手法では限界がある

<br/>

- 既存の静的アプローチは主にスレッドのインターリーブによって引き起こされるリソースベースのデッドロック検出に焦点を当てる
- 割り込みベースのデッドロックを見落としている
- 割り込みをスレッドとして直接扱うことで伝統的なスレッドインターリーブモデルを使用している
  - つまり, 同じスレッドで割り込みがあったときのデッドロックを見ていないということ?

<br/>

- 動的なアプローチはカバレッジが低く, 外部デバイスなどの実行環境に依存することが多い
- 動的ファジングは, Linux カーネル内蔵のロック検証ツールである Lockdep の支援によりデッドロックを検出できる
- これらは実行を欠陥のあるパスに導くために高品質のシード入力を可能にする
- さらに, 割り込み preemption は動的並行実行の探索空間を大幅に拡大し, 有効性を低下させる
- 割り込みの動的トリガーはハードウェアデバイスが生成する信号に大きく依存する
  - これは時に適切に実行・利用することが難しい

<br/>

<img src="./images/figure1.png" class="img-100" />

- 図1(a) の例はスレッドA とスレッドB の2つのスレッド間の循環ロック依存関係によって引き起こされる割り込みベースのデッドロックを示す
- スレッドA は184行目で &dev->irqlock を取得し, 195行目で関数 clear_work_bit() を呼び出し, 52行目で &dev->condlock を取得している
  - これによって &dev->irqlock から &dev->condlock へのロック依存関係が確立される
- スレッドB はコールバック関数 enc_post_frame_start() の中で, 300行目で clear_work_bit() 関数を呼び出し, &dev->irqlock を取得
- このとき, 割り込みハンドラ s5p_mfs_irq() は無効化されていないため, 52 から 54行目の間に, 割り込みハンドラが入る可能性がある
- この割り込みハンドラ内で &dev->irqlock を取得すると &dev->condlock から &dev->irqlock への割り込みロック依存関係が形成される
- この割り込みロック依存性は既存の静的メソッドでは取得できない
- 特定の並行スケジューリングでは図1(b) に示すような割り込みベースのデッドロックが発生し, システムが停止する可能性がある

<br/>

#### Our Approach

- 本論文は Linux カーネルにおける割り込みベースのデッドロックを検出するために, 割り込みの preemption を特徴づける初の静的アプローチ Archerfish を紹介する
- Archerfish は割り込み考慮ロックグラフ (Interrupt-Aware Lock Graph: ILG) を使う
  - ILG : スレッドの通常の実行フローと割り込み preemption によってそれぞれ引き起こされる, 通常のロック依存性と割り込みロック依存性の2つのロック依存性をキャプチャする
- ILG を効果的に構築することで割り込みベースのデッドロック検出を, 依存サイクルの発見と検証に減らすことができる
  - 例えば, 図1(a) のデッドロックは図1(c) のサイクルを見つけることで検出できる

<br/>

- しかし, Linux カーネルを効果的に解析してロックの依存関係を特定し, デッドロックサイクルを正確に作ることは3つの課題がある

  1. 割り込みサービスルーチン (ISR) (= 割り込みハンドラ?) の特定は, Linux カーネル内の異なるサブシステムが ISR を登録するために独自の API とコールバックインターフェースを持っていることが多いため, ドメイン固有の知識がないと困難
  2. 割り込みの preemption は静的解析の並行性推論空間を拡大する
     - 割り込みが有効な各プログラムは割り込みの可能性があるため, 各ステートメントすべてで割り込みを考慮する必要があるかも
  3. 割り込みとプログラムパスの両方の実現可能性を考慮して, 実現可能なロック依存関係を特定することが極めて重要
     - 例えば SMT を使って多数のロック依存関係のパスを直接検証することは効率が悪い

<br/>

<img src="./images/figure2.png" class="img-50" />

- この3つの課題に対処するため, 図2に示すような4つのステージを設計

<br/>

- 1つ目は, 1つ目の課題を解決するために, LLM の力を利用して, 割り込みを識別するために手動でモデル化したものを補完する割り込み仕様を生成する
- LLM は Linux カーネルに対する情報を含む膨大な量のオンラインテキストデータでトレーニングされているため

<br/>

- 2つ目は, ロックセットと関連するステートメントでの割り込みの有効/無効の状態を計算するために, サマリベースのデータフロー解析を採用する
- 割り込みの preemption が膨大な空間であるという課題に取り組むために, preemption unit という概念を導入し, クリティカルセクション内のすべてのステートメントをクラスタリングする
- 重要なアイデアは, クリティカルセクションが同じロックセットを共有し, その領域内で発生する割り込みが同じロックセットを保持すること
- ロックセット解析の際に, 領域内の個々のプログラムポイントを個別に計算する必要はない

<br/>

- 3つ目は, 計算されたデータフローの事実を使用して, ILG を構築し, 両方のロック依存関係をグラフエッジとしてキャプチャする
- ILG 内の依存サイクルを特定し, 割り込みベースのデッドロックを表す

<br/>

- 4つ目は, 高価なデッドロックの実現可能性チェックという課題の克服
- 重要なアイデアはすべてのロック依存性がデッドロック検出に関連しているわけではない
- ILG 構築中に各エッジを早期に検証する代わりに, 発見されたサイクルごとにコストのかかる検証を延期し, 割り込みとパスの両方の実現可能性を遅延的にチェックする

<br/>

- Archerfish は LLVM フレームワーク上で実装され, Linux v6.4 で評価した
- Linux カーネル (19.8 MLoC) を約1時間で比較的低い正解率 (49.7%) で解析することができる
- Linux カーネルの新しい, 長期にわたって存在する割り込みベースのデッドロックを発見した

<br/>

## 2. Background

### 2.1 Interrupts in Linux kernel

#### Interrupt Handling

- Linux カーネルにおける割り込みは, プログラムの通常の実行フローを変更する特別なイベント
  - このような動作を割り込み preemption と呼ぶ
- 対して, あるスレッドが別のスレッドに切り替える動作をスレッド preemption と呼ぶ
- 主な違いは, 割り込みはより優先度が高く, 割り込みの実行が終わるまで preempted な実行フローに切り替えることができない
- よって, 割り込みの preempted は新たなロック依存性を導入し, デッドロックを引き起こす可能性がある [[これ](https://github.com/torvalds/linux/commit/10af303192bc5490bb39b29541ecb0ead2eff1ce)]

<br/>

#### Interrupt Priority

- Linux カーネルにおける割り込みはハードウェア割り込みとソフトウェア割り込みがある
- ハードウェア割り込みは, ハードウェアデバイスからの割り込み信号によってトリガーされ, hardirq コンテキストと呼ばれるコンテキストで実行される
- 最近の Linux カーネルは hardirg コンテキストの内部では割り込みがデフォルトで無効になっているため, hardirq は最高の優先度で実行され, 他の実行によって割り込まれることはない

<br/>

- hardirq はハードウェア信号に対して素早く実行される必要があるため, 時間のかかるタスクは softirq に先送りされる
- softirq は hardirq よりも優先順位が低く, hardirq に先取りされるかも
- しかし, どちらも割り込みなので通常のカーネルスレッドよりも高い優先度を持つ
- これらの関係は Linux カーネル特有の並行実行モデルにつながる
- よって, 割り込みを考慮する静的解析はこれらの関係を考慮する必要がある

<br/>

#### Interrupt Service Routine (ISR) Registration

<img src="./images/figure3.png" class="img-50" />

- ISR (割り込みハンドラ?) はハードウェアデバイスからの割り込み信号やソフトウェア割り込みに応答する機能
- Linux カーネルでは, 通常 ISR は2つの方法で登録される
- 1つ目は構造体フィールドに割り当てられて登録される
  - 図3(a) では関数 ks_wlan_start_xmit() が, ネットワークパケット送信の処理を担当するコールバックインターフェースである net_device_ops.ndo_start_xmit 構造体フィールドに割り当てられることで softirq ISR として登録される
- 2つ目は特定の API 呼び出しの引数として渡されることで, ISR を登録することができる
  - 図3(b) のように関数 do_cio_interrupt() は標準 API の request_irq() を使用して, 割り込みライン IO_INTERRUPT に対する hardirq ISR として登録される
- Linux カーネルの大規模なコードベースには多様なサブシステムが含まれており, それぞれが ISR 登録のための独自のインターフェースや API を持っている
- これは ISR を特定し, 静的デッドロック解析で preemption を捕捉する上で困難になる

<br/>

### 2.2 Interrupt-Based Deadlocks

- 割り込みベースのデッドロックの他との違いは, 割り込み preemption によってもたらされるロック依存性の存在
- 先取りされたスレッドは ISR が完了するまで待機する必要がある
- その結果, 割り込まれたスレッドが保持するロックは ISR が完了するまで解放されない
- ISR 自身がロックを取得しようとすると, ロックの依存関係が生じ, ロックの取得が周期的になる可能性がある

<br/>

<img src="./images/figure4.png" class="img-50" />

- 例えば図4(a) ではロック $b$ がスレッド $T2$ によって保持されており, このスレッドは別のロック $a$ を取得する ISR に割り込まれる
- このシナリオでは ISR が終了するまで $T2$ がロック $b$ を解放できないため, 割り込みロック依存関係 $b \rightsquigarrow a$ が現れる
- $T1$ によって導入された通常のロック依存関係 $a \to b$ を考えると, 特定のスレッドと割り込みインターリーブの下で割り込みベースのデッドロックが発生するかも

<br/>

- スレッドの切り替えは割り込み preemption としてロック依存性 (例えば $b \rightsquigarrow a$) を導入できないことに注意
- これはあるスレッドがロックを保持しているときにスレッド切り替えが行われた場合, 取得したロックを解放するためにいつでもスレッド切り替えを戻すことができるため
- 割り込み preemmption によって生じるロック依存関係を割り込みロック依存関係と呼ぶ
- 割り込みロック依存関係を含むデッドロックを割り込みベースデッドロックと呼ぶ

<br/>

### 2.3 Limitations of Existing Static Detectors

- 既存の静的ロック検出技術は割り込みロックの依存関係を考慮せず, 割り込みをスレッドと同じようにモデル化する
- その結果割り込みベースのデッドロックを検出できない
- 図4(a) の割り込みは, 既存のデッドロック検出器では図4(b) のように, スレッド $T3$ としてモデル化され, 割り込み preemption がロック依存関係 $b \rightsquigarrow a$ を特定できない