# DDRace: Finding Concurrency UAF Vulnerabilities in Linux Drivers with Directed Fuzzing [Usenix-security'23]

## Abstract

- Linux ドライバにおける UAF 脆弱性の大部分は, 並行処理 UAF 脆弱性
- 本論文では, Linux ドライバにおける並行 UAF 脆弱性を効率的に発見するために, 並行 directed ファジング DDRace を提案
  1. ターゲットサイトとして UAF の候補となる場所を特定し, 関連する並行性要素を抽出し, directed ファジングの探索空間を削減
  2. UAF 脆弱性とスレッドのインターリーブをよく探索するようにファザーを誘導するために, 脆弱性に関連した新しい距離メトリクス (vulnerability-related distance metric) とインターリービング優先度スキーム (interleaving priority scheme) を設計
  3. テストケースの再現性を高めるために, 継続的にファジングを支援する適応的なカーネル状態移行スキーム (adaptive kernel state migration scheme) を設計
- DDRace を Linux カーネルドライバで評価すると並行 UAF を発見するのに効果的だった
  - 4つの未知の脆弱性と8つの既知の脆弱性を発見

<br/>

## 1. Introduction

- データレース, アトミック違反, デッドロックなど様々な並行性バグがある
- 並行性バグの中には, メモリ破壊, 情報リーク, 権限昇格など脆弱性につながるものもある (DirtyCow 脆弱性など)
- 特に並行性バグはイベントの時間的順序を変更し, UAF 脆弱性のような時間的メモリ安全性違反を引き起こしやすい
- Linux ドライバにおける UAF 脆弱性の大部分は並行性を含む [根拠](https://www.usenix.org/conference/atc19/presentation/bai)

<br/>

- 静的解析では happens-before 解析やロックセット解析を行い, レースペア候補 (happens-before 関係やロック同期を持たないメモリアクセスのペア) を特定する
- このようなレースペアは, 実行時に異なる順序を持つ可能性があり, 潜在的な並行性バグにつながる
- しかし, このような解決策は一つのレースペアしか考慮していないが, 並行 UAF の脆弱性は一般的に2つ以上のペアを含む
- 他にも DCUAF, UFO, ConVul などは happens-before 解析やロックセット解析を利用して, 並行 UAF を発見する
  - false-positive を除去するために多くの手作業が必要

<br/>

- もう一つの解決法はファジング
- データレースバグを発見するためにスレッドのインターリーブ空間も探索する
  - 積極的なスレッドスケジューリング機構
  - スレッドインターリーブフィードバック
- これらは並行 UAF 脆弱性よりもデータレースバグに焦点を当てている
- 有害なレースと無害なレースを区別することがほとんどできない
- さらに, スレッドのインターリーブ空間はファザーが探索するには広すぎる

<br/>

- これらを解決するために, Linux デバイスドライバの並行 UAF 脆弱性を発見するための並行 directed ファジング DDRace を提案する
- ファジングの探索空間を大幅に狭め, ターゲットサイトに迅速に到達することができる, いくつかの directed ファジングは過去にも提案された
- しかし, それらはテスト中にターゲットサイトまでの制御フロー距離またはデータ制約距離を考慮するだけであり, スレッドのインターリーブは考慮しない
  - 同じデータでスレッドのインターリーブが異なるテストケースは無視される
- DDRace は DGF を拡張してスレッドのインターリーブを考慮し, 以下の3つの課題を解決することで並行 UAF 脆弱性を効率的に発見する

<br/>

**C1: 無限の探索空間**

- DGF は一般的なファジングよりも探索空間が小さいが, 並行 UAF 脆弱性を発見するために必要なスレッドインターリーブ空間を探索していない
- しかし, これでは DGF の探索空間が再び拡大し, 脆弱性の発見効率が低下する

解決策

- 有向ファジングの対象を絞り込み, 候補となるスレッドのインターリーブ数を絞る
- 実行トレースを解析し, 実行時に同じオブジェクトにアクセスするが, 脆弱な順序となる可能性のある free と use の命令の場所を見つけ, 有向ファジングのターゲット候補としてマークする
- さらに, ターゲットとなる free, use に到達可能なすべてのドライバインターフェース (システムコール) を抽出し, 関連するドライバインターフェースの各ペアからデータレースペア (同じオブジェクトにアクセスするメモリ操作) を抽出
- これらのデータレースペアのインターリーブのみが DDRace によって探索される

<br/>

**C2: 並行 DGF の収束速度**

- 既存の DGF はファザーがターゲットを探索するように導くために制御フロー距離を使用する
  - スレッドのインターリーブやターゲットからアクセスされるオブジェクトは見ていない
- データレースファジング (KRACE など) は一つのレースペアの順序は取るが, 複数のレースペアの順序は無視する
- 並行 UAF 脆弱性を引き起こすには, ターゲットとなる free, use 命令を実行するだけでなく, 正しいインターリーブで同じオブジェクトにアクセスする必要がある
- さらに, これらのファザーはランダムなスレッドのインターリーブ探索を行い, 効果のないスレッドインターリーブを繰り返す可能性がある

解決策

- 脆弱性に関連した距離メトリクスとインターリーブ優先メカニズムを導入する
- 従来の制御フロー距離の改良に加え, ターゲットサイトで使用される複数のレースペアと値の順序の変化を追跡し, テストケースが UAF 脆弱性の制約をどの程度満たしているかを反映する新しい距離を計算する
- ファザーがシードを選択する際に, スレッドのインターリーブがあまり探索されていないシードテストケースを優先する

<br/>

**C3: テストケースの再現性**

- ほとんどのカーネルファザーは高いテストスループットのため, テスト対象のカーネルを再起動せずにテストケースを実行する
- syzkaller はクラッシュが報告されるかタイムアウトした後にのみ VM インスタンスを再起動する
- しかし, 持続的なファジングはカーネルの内部状態に継続的に影響を及ぼす
- カーネルを望ましい状態に設定するテストケースが選択された場合, カーネルが同じ状態に設定されない場合がある
- これでは PoC が再現できなくなる
- さらに, カーネルの状態によってターゲットサイトまでの距離が異なることがあり, 距離誘導ファジング戦略が不安定になる

解決策

- 適応的なカーネル状態スキームを採用
- QEMU のスナップショット機能を利用して, 適切なタイミングでカーネル状態のスナップショットを取得し, 復元されたスナップショット上でテストケースを再生することで, テストケースの再現性を確保する

<br/>

- DDRace を6つのデバイスドライバで評価した
- DDRace は素晴らしい