# DDRace: Finding Concurrency UAF Vulnerabilities in Linux Drivers with Directed Fuzzing [Usenix-security'23]

## Abstract

- Linux ドライバにおける UAF 脆弱性の大部分は, 並行処理 UAF 脆弱性
- 本論文では, Linux ドライバにおける並行 UAF 脆弱性を効率的に発見するために, 並行 directed ファジング DDRace を提案
  1. ターゲットサイトとして UAF の候補となる場所を特定し, 関連する並行性要素を抽出し, directed ファジングの探索空間を削減
  2. UAF 脆弱性とスレッドのインターリーブをよく探索するようにファザーを誘導するために, 脆弱性に関連した新しい距離メトリクス (vulnerability-related distance metric) とインターリービング優先度スキーム (interleaving priority scheme) を設計
  3. テストケースの再現性を高めるために, 継続的にファジングを支援する適応的なカーネル状態移行スキーム (adaptive kernel state migration scheme) を設計
- DDRace を Linux カーネルドライバで評価すると並行 UAF を発見するのに効果的だった
  - 4つの未知の脆弱性と8つの既知の脆弱性を発見

<br/>

## 1. Introduction

- データレース, アトミック違反, デッドロックなど様々な並行性バグがある
- 並行性バグの中には, メモリ破壊, 情報リーク, 権限昇格など脆弱性につながるものもある (DirtyCow 脆弱性など)
- 特に並行性バグはイベントの時間的順序を変更し, UAF 脆弱性のような時間的メモリ安全性違反を引き起こしやすい
- Linux ドライバにおける UAF 脆弱性の大部分は並行性を含む [根拠](https://www.usenix.org/conference/atc19/presentation/bai)

<br/>

- 静的解析では happens-before 解析やロックセット解析を行い, レースペア候補 (happens-before 関係やロック同期を持たないメモリアクセスのペア) を特定する
- このようなレースペアは, 実行時に異なる順序を持つ可能性があり, 潜在的な並行性バグにつながる
- しかし, このような解決策は一つのレースペアしか考慮していないが, 並行 UAF の脆弱性は一般的に2つ以上のペアを含む
- 他にも DCUAF, UFO, ConVul などは happens-before 解析やロックセット解析を利用して, 並行 UAF を発見する
  - false-positive を除去するために多くの手作業が必要

<br/>

- もう一つの解決法はファジング
- データレースバグを発見するためにスレッドのインターリーブ空間も探索する
  - 積極的なスレッドスケジューリング機構
  - スレッドインターリーブフィードバック
- これらは並行 UAF 脆弱性よりもデータレースバグに焦点を当てている
- 有害なレースと無害なレースを区別することがほとんどできない
- さらに, スレッドのインターリーブ空間はファザーが探索するには広すぎる

<br/>

- これらを解決するために, Linux デバイスドライバの並行 UAF 脆弱性を発見するための並行 directed ファジング DDRace を提案する
- ファジングの探索空間を大幅に狭め, ターゲットサイトに迅速に到達することができる, いくつかの directed ファジングは過去にも提案された
- しかし, それらはテスト中にターゲットサイトまでの制御フロー距離またはデータ制約距離を考慮するだけであり, スレッドのインターリーブは考慮しない
  - 同じデータでスレッドのインターリーブが異なるテストケースは無視される
- DDRace は DGF を拡張してスレッドのインターリーブを考慮し, 以下の3つの課題を解決することで並行 UAF 脆弱性を効率的に発見する

<br/>

**C1: 無限の探索空間**

- DGF は一般的なファジングよりも探索空間が小さいが, 並行 UAF 脆弱性を発見するために必要なスレッドインターリーブ空間を探索していない
- しかし, これでは DGF の探索空間が再び拡大し, 脆弱性の発見効率が低下する

解決策

- 有向ファジングの対象を絞り込み, 候補となるスレッドのインターリーブ数を絞る
- 実行トレースを解析し, 実行時に同じオブジェクトにアクセスするが, 脆弱な順序となる可能性のある free と use の命令の場所を見つけ, 有向ファジングのターゲット候補としてマークする
- さらに, ターゲットとなる free, use に到達可能なすべてのドライバインターフェース (システムコール) を抽出し, 関連するドライバインターフェースの各ペアからデータレースペア (同じオブジェクトにアクセスするメモリ操作) を抽出
- これらのデータレースペアのインターリーブのみが DDRace によって探索される

<br/>

**C2: 並行 DGF の収束速度**

- 既存の DGF はファザーがターゲットを探索するように導くために制御フロー距離を使用する
  - スレッドのインターリーブやターゲットからアクセスされるオブジェクトは見ていない
- データレースファジング (KRACE など) は一つのレースペアの順序は取るが, 複数のレースペアの順序は無視する
- 並行 UAF 脆弱性を引き起こすには, ターゲットとなる free, use 命令を実行するだけでなく, 正しいインターリーブで同じオブジェクトにアクセスする必要がある
- さらに, これらのファザーはランダムなスレッドのインターリーブ探索を行い, 効果のないスレッドインターリーブを繰り返す可能性がある

解決策

- 脆弱性に関連した距離メトリクスとインターリーブ優先メカニズムを導入する
- 従来の制御フロー距離の改良に加え, ターゲットサイトで使用される複数のレースペアと値の順序の変化を追跡し, テストケースが UAF 脆弱性の制約をどの程度満たしているかを反映する新しい距離を計算する
- ファザーがシードを選択する際に, スレッドのインターリーブがあまり探索されていないシードテストケースを優先する

<br/>

**C3: テストケースの再現性**

- ほとんどのカーネルファザーは高いテストスループットのため, テスト対象のカーネルを再起動せずにテストケースを実行する
- syzkaller はクラッシュが報告されるかタイムアウトした後にのみ VM インスタンスを再起動する
- しかし, 持続的なファジングはカーネルの内部状態に継続的に影響を及ぼす
- カーネルを望ましい状態に設定するテストケースが選択された場合, カーネルが同じ状態に設定されない場合がある
- これでは PoC が再現できなくなる
- さらに, カーネルの状態によってターゲットサイトまでの距離が異なることがあり, 距離誘導ファジング戦略が不安定になる

解決策

- 適応的なカーネル状態スキームを採用
- QEMU のスナップショット機能を利用して, 適切なタイミングでカーネル状態のスナップショットを取得し, 復元されたスナップショット上でテストケースを再生することで, テストケースの再現性を確保する

<br/>

- DDRace を6つのデバイスドライバで評価した
- DDRace は素晴らしい

<br/>

## 2. Background and Motiivation

### 2.1 Linux Drivers

- Linux カーネルはドライバを通じてハードウェアデバイスと相互作用する
- Linux デバイスドライバはカーネルドライバインターフェースのような特定のドライバインターフェースを実装する必要あり
- インターフェースを実装する関数はインターフェース関数と呼ばれ, ドライバのエントリポイントを形成する
- ドライバ内の全ての機能はドライバインターフェース関数から初期化される

<br/>

- ドライバの並行性はドライバインターフェースの並行実行によって決定される
- 並行実行の問題を発見しようとする場合, どのドライバインターフェースを並行実行できるか特定することが重要

<br/>

### 2.2 Concurrency UAF Vulnerabilities

- UAF はダングリングポインタに不正にアクセスする脆弱性
- 並行 UAF は UAF の特殊な種類で, マルチスレッドによって意図しないメモリ解放やアクセスが発生する
- このような脆弱性は Linux カーネルに多く深刻
- UAF 脆弱性の悪用 ( [これ](https://www.usenix.org/conference/usenixsecurity20/presentation/chen-hongxu) や [これ](https://dl.acm.org/doi/10.1145/2810103.2813637) )

<br/>

### 2.3 Gray-box Fuzzing

#### Directed Gray-box Fuzzing

- 有向ファジングの本質は指定されたプログラム位置 (ターゲットサイト) の集合に向かって集中的にファジングすること
- 既存の有向ファジングは, 入力がターゲットサイトにどれだけ近いかを測定する距離メトリクスを設計し, ターゲットサイトに到達する可能性の高い入力を優先する
- CAFL はターゲットサイトに順番に到達すべきと指摘し, 制約ベースの距離メトリクスを提案している
  - しかし, これはシーケンシャルな UAF だけに適用でき, 並行 UAF には適用できない
- 既存の DGF の研究では, マルチスレッドのインターリーブを考慮したものはなく, 到達可能性に対するスレッドインターリーブの影響を測るものもない

<br/>

#### Thread Scheduling

- スレッドスケジューリングは並行 UAF ファジングに不可欠
- 伝統的なコードカバレッジフィードバックに基づいて, スレッドを特定の順序で実行するように配置する研究もある ( [Razzer](https://ieeexplore.ieee.org/document/8835326), [Framework](https://dl.acm.org/doi/10.1145/3274694.3274718) )
- 最近の研究では新しい並行カバレッジをフィードバックとして用いて, スレッドインターリーブの探索空間の広い探索を目指す
- 並行カバレッジの指標としては, エイリアス命令のペア [Krace](https://ieeexplore.ieee.org/document/9152693), スレッドコンテキスト (ロック, アンロック, join コールサイトなど) [MUZZ](https://www.usenix.org/conference/usenixsecurity20/presentation/chen-hongxu) などがある

<br/>

- しかし, これらには限界がある
- 複数の興味深いペア間のスケジューリングを扱うことができず, 正確なスレッドインターリーブフィードバックを得ることを困難にしている
- また, 実行中に読み書き命令によるメモリ値の変更も無視される

<br/>

### 2.4 Motivating Example

#### A Real-World UAF Vulnerability

<img src="./images/figure1.png" class="img-60" />

- 図1はハードウェア端末への接続を管理するストリームドライバである, tty ドライバにおける並行 UAF 脆弱性 (CVE-2020-25656)
- 2つのスレッドがそれぞれシステムコール (ドライバインターフェース) $\mathtt{ioctl\$KDGKBSENT}$ と $\mathtt{ioctl\$KDSKBSENT}$ を実行し, 同時に実行できる
- スレッド1は 2023行目でグローバル配列 $\mathtt{func\_table}$ からポインタをフェッチし, 2025行目でそれをデリファレンスする
- スレッド2は 2078 行目で新しいヒープメモリを確保し, 2094行目で対応するポインタ $\mathtt{fnw}$ を $\mathtt{func\_table[i]}$ に格納し, 2104 行目でポインタ $\mathtt{funcbufptr}$ を通して, 前のヒープメモリを解放しようとする
- スレッド2が解放した後に, スレッド1が $\mathtt{func\_table}$ を介して解放されたメモリを使用する可能性があるため, 並行 UAF が発生する可能性がある

<br/>

#### Challenges to Find the UAF

- この UAF をトリガーするには, まずスレッド2の 2060行目で $\mathtt{else}$ ブランチを通る必要がある
- 次に I1, I2, I4, I3 の順で実行されると UAF が引き起こされる

<br/>

- しかし, このような並行 UAF をファジングで発見することは非常に難しい
- 3つの本質的な課題がある
- 一つ目はファジングが自動で行われるため, スレッドインターリーブを探索し, 脆弱性を誘発する適切なものを見つけるためにコードスニペットを何千回も際実行する必要がある
- しかし, Linux の膨大なコードベースと複雑性を考えると, ファザーがすべてのコードのスレッドインターリーブを探索しようとすると, 探索空間は無限に広がってしまう

<br/>

- 第2に, ファザーが1つの潜在的な脆弱性とその関連するコードスニペットだけに注目しても, ファザーが脆弱性をトリガーするための全ての制約を満たすことは困難
  - 制御フロー制約 (脆弱なコードの前に条件文があること)
  - データフロー制約 (free と use は同じメモリ位置を操作すること)
  - スレッドのインターリーブ
- 闇雲にファジングするのではなく, 実行情報から指針を得る必要あり
  - 例えば, 図1の UAF を見つけるために, ガイダンスのないファザーは無駄なスレッドインターリーブを繰り返す可能性あり
- 既存の研究では, 基本ブロックのコードカバレッジと入力距離をガイダンスとして使用し, カバレッジを増加させるか, 入力距離を短縮することを目指す
- しかし, それらはスレッドのインターリーブを考慮していない

<br/>

- 第3に, カーネルを頻繁にリブートする膨大なオーバーヘッドのため, ほとんどのカーネルファザーはテストケースを継続的に実行する
- その結果の課題は, カーネルの内部状態が蓄積され, 時間と共に変化することにある
- 状態の経年劣化の問題は, シードの再現性を低下させるため, ファザーの性能を低下させる
- 例えば図1では, 解放のターゲット (2104行目) に到達するには $\mathtt{delta} > \mathtt{funcbufleft}$ の条件で $\mathtt{else}$ の方に入る必要がある
- しかし, $\mathtt{func\_table}$ のようなグローバル変数は, ファジングの試行中に変化する
  - 例えば, 2110 行目のコードは文字列 $\mathtt{func\_table[i]}$ を変更することができ, 次のファジングでの $\mathtt{delta}$ の値を変更する
- その結果, 以前に成功した入力が 2104行目に到達すると, 永続的なカーネルのファジングで状態が変化するため, 後で失敗する可能性が高くなる

<br/>

## 3. DDRace

### 3.1 Overview

<img src="./images/figure2.png" class="img-75" />

- Linux ドライバの並行 UAF を効果的に発見するための, 新しい有向ファザー DDRace
- 図2は2つの段階からなるワークフロー
- 第一段階では軽量トレース解析を利用してターゲットサイト (潜在的な並行 UAF に関連するメモリアクセス命令 (USE) と解放命令 (FREE)) を特定する
- 次に DDRace はターゲットサイトに関連するドライバインターフェースを特定し, レースペアも特定する
- 第二段階では, ターゲットサイト周辺の並行 UAF を発見するために, レースペアでの計装から新しいガイダンスを使用して, スレッドインターリーブを探索する, 新しい並行有向グレーボックスファジングを実行する
- ファジングの間, DDRace は状態移行スキーム (state migration scheme) によって, 保存されたシードが期待されるカーネル状態と一致することを保証する

<br/>

#### Fuzzing Scope Identification (3.2)

- Linux カーネルの膨大なコードベースと複雑さを考えると, カーネル全体を徹底的にファジングすることは不可能
- 潜在的に脆弱性を誘発する可能性があるのはドライバインターフェースのごく一部
- したがって, DDRace はファジングの範囲を絞り込み, UAF をトリガーする確率の高いコードに焦点を当てる
- DDRace はまず, ファジングのターゲットサイト (UAF ペア) を取得し, コールグラフからターゲットサイトに到達できるドライバインターフェースを特定する
- 探索空間をさらに絞り込むために, DDRace は特定されたドライバインターフェース上で point-to 解析を行い, ターゲットに関連するレースペア (同じオブジェクトにアクセスするメモリオペレーションのペア)
- DDRace はファジングの段階で, データレースペアに関するインターリーブのみ探索する

<br/>

#### Directed Scheduling Fuzzing (3.3)

- 並行 UAF のための有向ファザーは, ターゲットサイトに到達するだけでなく, スレッドの実行順序など, 特定のスレッドスケジューリング要件も満たす必要がある
- コードカバレッジフィードバックしか持たない素朴なファザーはスレッドのインターリーブを見ない
- そのため, スレッドのインターリーブを十分に探索することができず, 並行 UAF を見つけることが難しくなる
- ファザーがスレッドのインターリーブを認識できるように, シード保存, シード選択, シード変異で新しい並行実行フィードバックを設計し, 制御フローとデータフローの両方でスレッドのインターリーブを探索できるように DDRace を誘導する
- さらに, ターゲットサイトに向けるために, DDRace は動的にキー変数の値を監視し, 特定のデータ制約を満たし, 脆弱性を誘発するために適切な値を選択する

<br/>

#### Adaptive State Migration (3.4)

- ほとんどのカーネルファザーは, カーネルを頻繁に再起動させるオーバーヘッド回避のため, 継続的に実行する
- カーネルの内部状態はファジング中に蓄積され, 変化する
- その結果, 同じテストケースであっても, 状態が変化すると挙動が異なる (カバレッジや距離が異なる) 可能性がある
- 状態の老化問題は並行有向ファジングを効果的にしない
- 以前は成功したテストケースが異なる状態や時間で実行されるとターゲットサイトに到達できないかも
- DDRace は状態スナップショットによってこの問題を解決する
- DDRace はファジング中のカーネル状態のスナップショットを保存する
- テストケースを特定の状態で実行する必要がある場合, DDRace は対応するスナップショットを復元し, テストケースを実行する
- カーネル状態とテストケースの一貫性を保つことは有向カーネルファジングの効率を向上させる