# Mutation Mechanism

[Diving into Syzkaller’s mutation mechanism](https://gwangmu.medium.com/diving-into-syzkallers-mutation-mechanism-1-3-f15036a4087a)

<br/>

## Introduction

- ファザーの効率は変異させた入力の品質に依存する
  - カーネルがすぐにエラー処理などで拒絶するものであってはならない
  - 問題を引き起こす微妙な部分も残ってなくてはならない
- 入力に特定のフォーマットやテンプレートが必要な場合はさらに難しい

<br/>

- 最小限の許容された入力は一連のシステムコールとその引数で構成される必要がある
- これを変異させることは単に入力のバイトを変異させることよりも難しい
- このページでは syzkaller の変異メカニズムを説明する

<br/>

## 0. Selecting a mutaion input

- syzkaller が変異させる入力をどのように選択するか
- キューにタスクがなく (入力の triaging や smashing など), 入力をゼロから生成しないとき (入力をゼロから生成することは滅多にない), コーパスからランダムに入力を選択する

<br/>

## 1. Selecting a mutaion method

- 最初は変異メソッドの選択を行う
- syzkaller には5つの変異メソッドがある
  - システムコールのスプライシング (組み合わせる)
  - システムコールの挿入
  - システムコールの削除
  - 引数のスクワッシング (削除というか減少みたいな; `null` にするとか)
  - 引数の変異
- mutator は変異の試みが失敗するか, 確率的に停止するか (確率 1/3?), 変異した入力が最大システムコール数を超えるまで, 変異を繰り返す
  - 一回の変異あたりっぽい
- 各変異メソッドは選択される確率が異なる
  - システムコールの挿入と引数の変異が最も確率が高いらしい

<br/>

## 2. Program mutation

- 5つの変異メソッドはアルゴリズムの複雑さが異なる
- 最も確率の低い2つは非常に単純な一方, 確率の高い2つは非常に複雑
  - 複雑なものの確率を上げているのかも?
  - 単純なものに比べて複雑なもののコード量は約10倍
- 以下では, 単純なものから複雑なものまで順番に説明

<br/>

### 2.1 Removing a syscall

- 最も単純な変異メソッド
- 入力からシステムコールを選び, それを削除する
- どのシステムコールが削除されるかはランダムっぽい

<br/>

### 2.2 Splicing syscalls

- スプライシングは2つの入力の組み合わせ
- syzkaller では基本的に2つ目の入力全体を1つ目の入力のランダムなポイントに挿入する
  - 2つ目の入力もランダムに決定される 
  - 例えば, 入力A (A1:A2 となる) と入力Bをスプライシングすることを考える
  - mutator は入力Aの中のある点をランダムに選択し (A1 と A2 の間だとする), その点に入力Bを挿入する (最終結果は A1:B:A2 となる)
- 最終結果がシステムコールの最大数を超える場合はいくつか削除する

<br/>

### 2.3 Squashing a pointer argument

<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2EV9X-Kfj1gs5kQp" class="img-80" />

- ポインタ引数の squashing は syzkaller にとって重要
  - 各引数には独自の種類があり, それに応じて異なるロジックで変異する
- ポインタの squashing では複雑なメモリオブジェクト (構造体, ユニオンなど) をフラットなバイトバッファのシーケンスに変換する
  - これによって, 後続の変異がバイトレベルで変異することができる
- 上の図では, squashing 操作はフィールド a, b, c, d とその間のパディングを 1つのバイトバッファ a_to_d にまとめる
- しかし, 値が別のシステムコールの結果によって決定される場合は, その部分を別個のエンティティとして残す
- mutator はどのポインタを squashing するかをランダムに選択する

<br/>

- squashing はカーネルから見てまったく入力を変えていないことに注意
- カーネルは構造体かバイト配列かに関わらず, 入力の同じバイト表現を見る
- その代わり, このアルゴリズムでは squashing の後, ランダムバイトバッファを追加で変異させる
- mutater が構造体やユニオンをバイト配列であるかのように壊すというイメージ