# Mutation Mechanism

[Diving into Syzkaller’s mutation mechanism](https://gwangmu.medium.com/diving-into-syzkallers-mutation-mechanism-1-3-f15036a4087a)

<br/>

## Introduction

- ファザーの効率は変異させた入力の品質に依存する
  - カーネルがすぐにエラー処理などで拒絶するものであってはならない
  - 問題を引き起こす微妙な部分も残ってなくてはならない
- 入力に特定のフォーマットやテンプレートが必要な場合はさらに難しい

<br/>

- 最小限の許容された入力は一連のシステムコールとその引数で構成される必要がある
- これを変異させることは単に入力のバイトを変異させることよりも難しい
- このページでは syzkaller の変異メカニズムを説明する

<br/>

## 0. Selecting a mutaion input

- syzkaller が変異させる入力をどのように選択するか
- キューにタスクがなく (入力の triaging や smashing など), 入力をゼロから生成しないとき (入力をゼロから生成することは滅多にない), コーパスからランダムに入力を選択する

<br/>

## 1. Selecting a mutaion method

- 最初は変異メソッドの選択を行う
- syzkaller には5つの変異メソッドがある
  - システムコールのスプライシング (組み合わせる)
  - システムコールの挿入
  - システムコールの削除
  - 引数のスクワッシング (削除というか減少みたいな; `null` にするとか)
  - 引数の変異
- mutator は変異の試みが失敗するか, 確率的に停止するか (確率 1/3?), 変異した入力が最大システムコール数を超えるまで, 変異を繰り返す
  - 一回の変異あたりっぽい
- 各変異メソッドは選択される確率が異なる
  - システムコールの挿入と引数の変異が最も確率が高いらしい

<br/>

## 2. Program mutation

- 5つの変異メソッドはアルゴリズムの複雑さが異なる
- 最も確率の低い2つは非常に単純な一方, 確率の高い2つは非常に複雑
  - 複雑なものの確率を上げているのかも?
  - 単純なものに比べて複雑なもののコード量は約10倍
- 以下では, 単純なものから複雑なものまで順番に説明

<br/>

### 2.1 Removing a syscall

- 最も単純な変異メソッド
- 入力からシステムコールを選び, それを削除する
- どのシステムコールが削除されるかはランダムっぽい

<br/>

### 2.2 Splicing syscalls

- スプライシングは2つの入力の組み合わせ
- syzkaller では基本的に2つ目の入力全体を1つ目の入力のランダムなポイントに挿入する
  - 2つ目の入力もランダムに決定される 
  - 例えば, 入力A (A1:A2 となる) と入力Bをスプライシングすることを考える
  - mutator は入力Aの中のある点をランダムに選択し (A1 と A2 の間だとする), その点に入力Bを挿入する (最終結果は A1:B:A2 となる)
- 最終結果がシステムコールの最大数を超える場合はいくつか削除する

<br/>

### 2.3 Squashing a pointer argument

<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2EV9X-Kfj1gs5kQp" class="img-80" />

- ポインタ引数の squashing は syzkaller にとって重要
  - 各引数には独自の種類があり, それに応じて異なるロジックで変異する
- ポインタの squashing では複雑なメモリオブジェクト (構造体, ユニオンなど) をフラットなバイトバッファのシーケンスに変換する
  - これによって, 後続の変異がバイトレベルで変異することができる
- 上の図では, squashing 操作はフィールド a, b, c, d とその間のパディングを 1つのバイトバッファ a_to_d にまとめる
- しかし, 値が別のシステムコールの結果によって決定される場合は, その部分を別個のエンティティとして残す
- mutator はどのポインタを squashing するかをランダムに選択する

<br/>

- squashing はカーネルから見てまったく入力を変えていないことに注意
- カーネルは構造体かバイト配列かに関わらず, 入力の同じバイト表現を見る
- その代わり, このアルゴリズムでは squashing の後, ランダムバイトバッファを追加で変異させる
- mutator が構造体やユニオンをバイト配列であるかのように壊すというイメージ

<br/>

### 2.4 Inserting a syzcall

- この変異が目指すもの
  - ヒント: たくさんのシステムコールがあり, それぞれがカーネルの異なる部分をアクティブにする
- ランダムなシステムコールが入力 (既存のシステムコール) に挿入された時, この新しいシステムコールが既存のものと相互作用する確率を考える
- システムコールは互いに作用し合って興味深いプログラム状態を作り出す
- 逆に新しいシステムコールが別のシステムコールとまったく無関係の場合, 変異した入力は同じプログラム状態に無関係な実行を加えたものを実行するだけであり, 時間の無駄でしかない

<br/>

- つまり, 変異した入力を面白くするために, 関連するシステムコールを挿入する
- syzkaller が行うのは, 入力に既存のシステムコールに対して, より関連性の高いシステムコールを選択することである
- これはさらに2つの部分に分けることができる
  - システムコールのペア間の関連性を計算すること
  - 計算された関連性に基づいて新しいシステムコールを選択すること

<br/>

#### 2.4.1 Calculating the relevance between a syscall pair

- システムコールの関連性は syz-manager が起動し, choice table を構築するときに計算される
  - choice table: あるシステムコールとそれらの関連性を指定したもの
- syzkaller は2つの方法で各システムコールのペアの関連性を計算する
  - 1つ目は静的な情報を利用し, システムコールの仕様 (引数の型やデータフローの方向性?) を指定する方法
  - 2つ目はコーパスの動的な情報を利用し, 1つの入力で同時に出現する可能性のあるシステムコールのペアを示す方法
- この情報からどのように関連性を導き出すかは, ヒューリスティクスの部分が大きい

<br/>

<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_yMNmrNPOMSFHrCF" class="img-80" />


- まずは静的な部分を見ていく
- 静的情報では各システムコールの詳細, 具体的にはシステムコールの各引数の型を指定する
- syzkaller はさらに, これらの型を期待される使用方法にしたがって **リソース** として分割し, 与えられたシステムコールがどのリソースを使用するかを計算する
- システムコールの関連性を計算する際に, 特定のリソースの使用を別のリソースよりも重みを付ける
  - この重みの値はヒューリスティックに決定された定数

<br/>

- syzkaller が各システムコールのリソース使用を特定した
- 次のタスクは各システムコールペアの関連性を推定するために, この使用を利用すること
- システムコールの (順序づけられた) ペアが与えられたら, リソースの 生成/消費 に応じて, それらの間に関連性スコア (syzkaller 用語では priority) を割り当てる
- 前段落の重みは, システムコールが特定のリソースをどの程度生成/消費するかを示す
- 上の図では静的関連性計算の概要を示しており, ()内の数字はリソース使用の重みを示す

<br/>

- 動的な方法では, 現在のコーパスのすべての入力をスキャンし, 2つのシステムコールが同じ入力に現れるかをチェックする
- 2つのシステムコールが同時に現れれば現れるほどその関連性は高くなる
- 静的関連性と動的関連性の合計値が各システムコールペアの関連性

<br/>

#### 2.4.2 Inserting a new syscall

- syzkaller は挿入する新しいシステムコールを選択する前に, どこに挿入するかを決定する
- mutator は挿入ポイントをランダムに決定するが, 確率はシーケンスの最後に偏る
  - $n$ 番目に挿入する確率は $n$ に比例して高くなる

<br/>

- この偏りの意味を理解する
- 基本的に新しいシステムコールを最後に置くことは, 関連する計算をより多く行うことを意味する
- 元の入力はある程度動作しており, これを別の関連するシステムコールで拡張することで, 新しいプログラム状態を構築する可能性がある
- 一方, システムコールを間に挿入することは, それ以降のシステムコールシーケンスが壊れる可能性があるが, それでも新しいプログラム状態を作る可能性があるため, 完全に抑制はできない

<br/>

- 挿入ポイントを選択した後, 挿入するシステムコールを決定する
  - ここで関連性スコアが使われる
- 挿入するポイントに先行するランダムなシステムコール (参照システムコール) を一つ選び, 参照システムコールに関連する新しいシステムコールを選択する
- 挿入されるシステムコールはランダムに選ばれるが, この参照システムコールとの関連性を高めるために, 参照システムコールとそれぞれのシステムコールとの間の関連性によって, ランダムな抽選に重み付けがされる

<br/>

### 2.5 Mutating syscall arguments

- システムコールの引数の変異は, 実装では最も洗練されているが, アイデアは単純なもの
- 入力からランダムにシステムコールを選び, その引数の一部をランダムに変異させる
- しかし, ランダムな選び方は特別なものだ

<br/>

#### 2.5.1 Choosing a syscall

- 引数を変異する際に初めにやることは, 入力からシステムコールを選択すること
- これは完全なランダムではなく, どの引数を持つかによってシステムコールごとに重み付けされる
  - 変異させる価値のない引数をもつシステムコールを選択したくない
- システムコールの重みは各引数の合計として決定される
- 引数の重みはその引数の型によって決定される
  - 一般的にその引数の変異が大きな影響を与える場合に重みは大きくなる

<br/>

- syzkaller は重みを使ってランダムに何かを選択する場合はほとんど同じアルゴリズムを用いる
  - すべての重みを積み上げる ($\{2,3,5,4\}$ という重み4つがあるなら, $\{2,5,10,14\}$)
  - すべての重みの合計値より小さい乱数を引く (例えば $8$)
  - それまでの累積値が乱数より大きい最初の重みを選択する (ここでは3番目の要素 $5$ が選択される)

<br/>

#### 2.5.2 Mutating arguments

- 変異させる引数の選択はシステムコールの選択と似ているが, これは複数回実施される可能性がある
- 実際の引数の変異の方法は, 引数の型に依存する
- いくつかの引数の変異は, 副作用として追加のシステムコールを導入する可能性がある