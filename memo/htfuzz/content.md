# HTFuzz: Heap Operation Sequence Sensitive Fuzzing [ASE'22]

## Abstract

- heap の時間的脆弱性 (use-after-free, double-free, null ポインタデリファレンス) はヒープ操作の順番に敏感
- この脆弱性を効率的に発見するために従来のコードカバレッジファジングにヒープ操作のシーケンスのフィードバックを統合することが良い
- しかし, 既存手法には限界がある

<br/>

- HTFuzz を提案
- 以下の理由からファジングを利用
  - 実行時のヒープ操作シーケンスのカバレッジを増加させる
    - ヒープ操作シーケンスの制御フローを反映
  - これらの操作によってアクセスされるポインタの多様性を増加させる
    - データフローを反映
- (HTfuzz は実験の結果すごいらしい)

<br/>

## 1. Introduction

- 既存のファザーは一般にコードカバレッジフィードバックに依存している
  - AFL
  - TortoiseFuzz, Ankou: 補足的なフィードバックとして, よりエラーの発生しやすい箇所 (システムコールとループ反復など) を探索しようとする

<br/>

- しかし, ヒープの時間的脆弱性 (HT-Vuls) はコードカバレッジだけでなく, ヒープ操作のシーケンスにも敏感
- ファザーがポインタのデリファレンスコードを探索したとしても脆弱なヒープ操作のシーケンスを満たしていなければ, HT-Vuls を見逃すかも
- HT-Vuls はアクセスされたポインタとその前の操作シーケンスに密接に関係する

<br/>

- 研究者はファジング中にヒープ操作シーケンスを考慮するためのいくつかの解決案を提案している
- それらは脆弱性のある操作の候補を認識するために事前知識や静的解析に依存する
  - [UAFL](https://yuleisui.github.io/publications/icse20.pdf) : 静的解析を利用して HT-Vuls の候補となるヒープ操作を見つけ, ヒープ操作間の遷移を新しいフィードバックとして受け取り, ファザーをターゲットの操作シーケンスに誘導する
  - [LTL-Fuzzer](https://abhikrc.com/pdf/ICSE22-LTLFuzz.pdf) : 時間的な違反に関連する場所で計装し, ファザーがその場所を探索するように誘導する
  - [UAFuzz](https://www.usenix.org/system/files/raid20-nguyen.pdf) : ユーザによって事前に定義された UAF 箇所を探索するために有向ファジングを実行する
- 事前知識や静的解析に依存するため限界がある

<br/>

- HTFuzz : 事前に定義・分析された操作シーケンスの候補に依存しない, ヒープ操作シーケンスガイドファジング
- 限られた操作シーケンスの候補集合を探索することに集中せず, ヒープ操作シーケンスの多様性を高めることを提案する
- 具体的には
  - ヒープ操作シーケンスを追跡し, 
  - コードカバレッジに加えて新たなフィードバックを使用し, 
  - 多様性を高めるようにファザーを誘導する
- ヒープ操作シーケンスの多様性が高まれば, 潜在的な HT-Vuls を発見できる
- 3つの RQ がある

<br/>

- RQ1: ヒープ操作シーケンス・フィードバック取得のオーバーヘッド
- 一般にテストケース実行トレースにおけるヒープ操作の数は非常に多い
  - ファザーが実行時にすべての操作とその順序を記録するのは時間がかかり, メモリが大きすぎる
- さらに, 2つのテストケースのヒープ操作シーケンスを比較することは困難
- シーケンスフィードバックのオーバーヘッドと粒度のバランスを取る
  - HTFuzz ではリングバッファを使用して, 最新の alloc/dealloc 操作を追跡
  - メモリアクセス操作ごとにリングバッファのハッシュをインデックスとして, シーケンスカバレッジビットマップを更新する

<br/>

- RQ2: ポインタエイリアスの感度
- HT-Vuls は操作のシーケンスだけでなく, ポインタの情報も必要
- ポインタのエイリアスが多いほど HT-Vuls が起こりやすくなる
- ファジング中にポインタとそのエイリアスを追跡することは重要だが, 正確な追跡はコストがかかる
- HTFuzz
  - ファジング中にヒープ操作によってアクセスされるポインタ (とエイリアス) の数をカウント
  - シード選択時により多くのポインタにアクセスするテストケースを優先する

<br/>

- RQ3: コードカバレッジフィードバックとの協調
- コードカバレッジフィードバックとヒープ操作シーケンスフィードバックを組み合わせることは合理的
- これら2つのフィードバックは衝突する可能性がある
  - AFL はコードカバレッジに寄与しそうなバイトのみを変異させる
  - スキップされたバイトはヒープ操作シーケンスの多様性に寄与するかも
- HTFuzz
  - ヒープ操作シーケンスも考慮するようにエフェクタマップ識別アルゴリズムをアップグレード
  - MOPT を利用して変異を動的にスケジューリングする (変異の確率?)

<br/>

#### まとめ

1. 新しいヒープ操作シーケンスフィードバックを導入し, シードの保存戦略を調整することで, ヒープ操作シーケンスの制御フローの多様性を高める
2. ヒープ操作によってアクセスされるポインタとエイリアスの数をカウントし, シード選択戦略を調整することで, ヒープ操作シーケンスのデータフローの多様性を高める
3. コードカバレッジと操作シーケンスの2つのフィードバックを連携させるために, シードの変異戦略を調整する

<br/>

もっとまとめると
1. シードの保存戦略
2. シードの選択戦略
3. シードの変異戦略